import pandas as pd
import numpy as np

from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn import metrics
from matplotlib import pyplot as plt


class KSModel(object):
    """
    Kick started prediction model class.
    """
    classifier = RandomForestClassifier(n_estimators=100)  # Random Forest classifier with 100 decision trees

    def __init__(self, data_path: str):
        self.data = pd.read_csv(data_path, index_col=False)
        self.x = None
        self.y = None
        self.x_train = None
        self.x_test = None
        self.y_train = None
        self.y_test = None
        self.scaler = None

    def data_transformer(self, data_path=None) -> (np.array, np.array):
        """
        Transform the given data file to the required form by doing cleaning and removal.
        :param data_path: Path to the data file
        :return: Transformed input data and labels.
        """
        if data_path is not None:
            self.data = pd.read_csv(data_path, index_col=False)
        self.data['deadline'] = pd.to_datetime(self.data['deadline'], infer_datetime_format=True)
        self.data['launched'] = pd.to_datetime(self.data['launched'], infer_datetime_format=True)
        data_required = self.data[self.data['state'].isin(['failed', 'successful'])]
        data_required = data_required.assign(
            duration=pd.Series((data_required['deadline'] - data_required['launched']).dt.days))
        data_required['year'] = data_required['launched'].dt.year
        data_required['month'] = data_required['launched'].dt.month_name()
        data_required['weekday'] = data_required['launched'].dt.weekday_name
        data_required = data_required.drop(
            ['ID', 'name', 'currency', 'goal', 'pledged', 'usd pledged', 'deadline', 'launched'], axis=1)
        data_required.reset_index(drop=True, inplace=True)
        labels = data_required['state'].tolist()
        labels = np.asarray([1 if label == 'successful' else 0 for label in labels])
        x_data = data_required.drop(['state'], axis=1)
        x_data = pd.get_dummies(x_data).values
        return x_data, labels

    def data_processing(self) -> None:
        """
        Performs removal, scaling and splitting on given data.
        :return: None
        """
        x_data, labels = self.data_transformer()
        self.scaler = MinMaxScaler()
        self.scaler.fit(x_data)
        self.x = self.scaler.transform(x_data)
        self.y = labels
        self.x_train, self.x_test, self.y_train, self.y_test = train_test_split(self.x,
                                                                                self.y,
                                                                                test_size=0.2,
                                                                                random_state=42)

    def train_model(self) -> None:
        """
        Train the random forest classifier with the generated training data.
        :return: None
        """
        self.classifier.fit(self.x_train, self.y_train)

    def process_custom_data(self, data_path: str) -> (np.array, np.array):
        """
        Pre-process custom test data for making predictions.
        :param data_path: Path to the custom test data file.
        :return: Processed custom x and y.
        """
        x_data, labels = self.data_transformer(data_path)
        x_custom = self.scaler.transform(x_data)
        return x_custom, labels

    def make_prediction(self, x_test=None) -> object:
        """
        Calculate predictions on given test data.
        :param x_test: Test input data.
        :return: Predictions generated by the model.
        """
        if x_test is None:
            x_test = self.x_test
        return self.classifier.predict(x_test)

    def evaluate_model(self, x_test=None, y_test=None) -> None:
        """
        Evaluate the Random forest model with metrics like accuracy, precision, recall, f1 score and auc.
        Plot the precision recall curve.
        :param x_test: Test input test data.
        :param y_test: Test labelled data.
        :return: None
        """
        if x_test is None:
            x_test = self.x_test
        if y_test is None:
            y_test = self.y_test
        pred = self.make_prediction(x_test)
        accuracy = self.classifier.score(x_test, y_test)
        print('Accuracy of predictions: {0} %'.format(accuracy * 100))
        precision = metrics.precision_score(y_test, pred)
        recall = metrics.recall_score(y_test, pred)
        f1_score = metrics.f1_score(y_test, pred)
        print('Precision score: {0}'.format(precision))
        print('Recall score: {0}'.format(recall))
        print('F1 score: {0}'.format(f1_score))
        pred_prob = self.classifier.predict_proba(x_test)
        pr, rc, thres = metrics.precision_recall_curve(y_test, pred_prob[:, 1])
        auc = metrics.auc(rc, pr)
        print('Area Under the Curve: {0}'.format(auc))
        plt.plot(rc, pr)
        plt.xlabel('Recall')
        plt.ylabel('Precision')
        plt.title('Precision Recall Curve')
        plt.show()
